// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TcpProto.proto

#ifndef PROTOBUF_TcpProto_2eproto__INCLUDED
#define PROTOBUF_TcpProto_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_TcpProto_2eproto();
void protobuf_AssignDesc_TcpProto_2eproto();
void protobuf_ShutdownFile_TcpProto_2eproto();

class Person;
class RegistReq;
class RegistRes;
class LoginReq;
class LoginRes;
class LogoutReq;
class LogoutRes;
class ShakeMsg;
class TextMsgPrivate;
class TextMsgGroup;
class TcpHeartBeatReq;
class TcpHeartBeatRes;

// ===================================================================

class Person : public ::google::protobuf::Message {
 public:
  Person();
  virtual ~Person();

  Person(const Person& from);

  inline Person& operator=(const Person& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Person& default_instance();

  void Swap(Person* other);

  // implements Message ----------------------------------------------

  Person* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Person& from);
  void MergeFrom(const Person& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string sex = 4;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 4;
  inline const ::std::string& sex() const;
  inline void set_sex(const ::std::string& value);
  inline void set_sex(const char* value);
  inline void set_sex(const char* value, size_t size);
  inline ::std::string* mutable_sex();
  inline ::std::string* release_sex();
  inline void set_allocated_sex(::std::string* sex);

  // required int32 head = 5;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 5;
  inline ::google::protobuf::int32 head() const;
  inline void set_head(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:Person)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_head();
  inline void clear_has_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::std::string* password_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 head_;
  ::std::string* sex_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static Person* default_instance_;
};
// -------------------------------------------------------------------

class RegistReq : public ::google::protobuf::Message {
 public:
  RegistReq();
  virtual ~RegistReq();

  RegistReq(const RegistReq& from);

  inline RegistReq& operator=(const RegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistReq& default_instance();

  void Swap(RegistReq* other);

  // implements Message ----------------------------------------------

  RegistReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistReq& from);
  void MergeFrom(const RegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string nickname = 1;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 1;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // required string sex = 3;
  inline bool has_sex() const;
  inline void clear_sex();
  static const int kSexFieldNumber = 3;
  inline const ::std::string& sex() const;
  inline void set_sex(const ::std::string& value);
  inline void set_sex(const char* value);
  inline void set_sex(const char* value, size_t size);
  inline ::std::string* mutable_sex();
  inline ::std::string* release_sex();
  inline void set_allocated_sex(::std::string* sex);

  // required int32 head = 4;
  inline bool has_head() const;
  inline void clear_head();
  static const int kHeadFieldNumber = 4;
  inline ::google::protobuf::int32 head() const;
  inline void set_head(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegistReq)
 private:
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_sex();
  inline void clear_has_sex();
  inline void set_has_head();
  inline void clear_has_head();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* nickname_;
  ::std::string* password_;
  ::std::string* sex_;
  ::google::protobuf::int32 head_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static RegistReq* default_instance_;
};
// -------------------------------------------------------------------

class RegistRes : public ::google::protobuf::Message {
 public:
  RegistRes();
  virtual ~RegistRes();

  RegistRes(const RegistRes& from);

  inline RegistRes& operator=(const RegistRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegistRes& default_instance();

  void Swap(RegistRes* other);

  // implements Message ----------------------------------------------

  RegistRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegistRes& from);
  void MergeFrom(const RegistRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:RegistRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 code_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static RegistRes* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::Message {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginReq& default_instance();

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string password = 2;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 2;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:LoginReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* password_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginRes : public ::google::protobuf::Message {
 public:
  LoginRes();
  virtual ~LoginRes();

  LoginRes(const LoginRes& from);

  inline LoginRes& operator=(const LoginRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LoginRes& default_instance();

  void Swap(LoginRes* other);

  // implements Message ----------------------------------------------

  LoginRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LoginRes& from);
  void MergeFrom(const LoginRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // repeated .Person person = 2;
  inline int person_size() const;
  inline void clear_person();
  static const int kPersonFieldNumber = 2;
  inline const ::Person& person(int index) const;
  inline ::Person* mutable_person(int index);
  inline ::Person* add_person();
  inline const ::google::protobuf::RepeatedPtrField< ::Person >&
      person() const;
  inline ::google::protobuf::RepeatedPtrField< ::Person >*
      mutable_person();

  // @@protoc_insertion_point(class_scope:LoginRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::Person > person_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static LoginRes* default_instance_;
};
// -------------------------------------------------------------------

class LogoutReq : public ::google::protobuf::Message {
 public:
  LogoutReq();
  virtual ~LogoutReq();

  LogoutReq(const LogoutReq& from);

  inline LogoutReq& operator=(const LogoutReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutReq& default_instance();

  void Swap(LogoutReq* other);

  // implements Message ----------------------------------------------

  LogoutReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutReq& from);
  void MergeFrom(const LogoutReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:LogoutReq)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static LogoutReq* default_instance_;
};
// -------------------------------------------------------------------

class LogoutRes : public ::google::protobuf::Message {
 public:
  LogoutRes();
  virtual ~LogoutRes();

  LogoutRes(const LogoutRes& from);

  inline LogoutRes& operator=(const LogoutRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LogoutRes& default_instance();

  void Swap(LogoutRes* other);

  // implements Message ----------------------------------------------

  LogoutRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LogoutRes& from);
  void MergeFrom(const LogoutRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 code = 1;
  inline bool has_code() const;
  inline void clear_code();
  static const int kCodeFieldNumber = 1;
  inline ::google::protobuf::int32 code() const;
  inline void set_code(::google::protobuf::int32 value);

  // required .Person person = 2;
  inline bool has_person() const;
  inline void clear_person();
  static const int kPersonFieldNumber = 2;
  inline const ::Person& person() const;
  inline ::Person* mutable_person();
  inline ::Person* release_person();
  inline void set_allocated_person(::Person* person);

  // @@protoc_insertion_point(class_scope:LogoutRes)
 private:
  inline void set_has_code();
  inline void clear_has_code();
  inline void set_has_person();
  inline void clear_has_person();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::Person* person_;
  ::google::protobuf::int32 code_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static LogoutRes* default_instance_;
};
// -------------------------------------------------------------------

class ShakeMsg : public ::google::protobuf::Message {
 public:
  ShakeMsg();
  virtual ~ShakeMsg();

  ShakeMsg(const ShakeMsg& from);

  inline ShakeMsg& operator=(const ShakeMsg& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ShakeMsg& default_instance();

  void Swap(ShakeMsg* other);

  // implements Message ----------------------------------------------

  ShakeMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ShakeMsg& from);
  void MergeFrom(const ShakeMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline ::google::protobuf::int32 src() const;
  inline void set_src(::google::protobuf::int32 value);

  // required int32 dst = 2;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 2;
  inline ::google::protobuf::int32 dst() const;
  inline void set_dst(::google::protobuf::int32 value);

  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:ShakeMsg)
 private:
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dst();
  inline void clear_has_dst();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static ShakeMsg* default_instance_;
};
// -------------------------------------------------------------------

class TextMsgPrivate : public ::google::protobuf::Message {
 public:
  TextMsgPrivate();
  virtual ~TextMsgPrivate();

  TextMsgPrivate(const TextMsgPrivate& from);

  inline TextMsgPrivate& operator=(const TextMsgPrivate& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMsgPrivate& default_instance();

  void Swap(TextMsgPrivate* other);

  // implements Message ----------------------------------------------

  TextMsgPrivate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextMsgPrivate& from);
  void MergeFrom(const TextMsgPrivate& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline ::google::protobuf::int32 src() const;
  inline void set_src(::google::protobuf::int32 value);

  // required int32 dst = 2;
  inline bool has_dst() const;
  inline void clear_dst();
  static const int kDstFieldNumber = 2;
  inline ::google::protobuf::int32 dst() const;
  inline void set_dst(::google::protobuf::int32 value);

  // required string data = 3;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 3;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:TextMsgPrivate)
 private:
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_dst();
  inline void clear_has_dst();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 src_;
  ::google::protobuf::int32 dst_;
  ::std::string* data_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static TextMsgPrivate* default_instance_;
};
// -------------------------------------------------------------------

class TextMsgGroup : public ::google::protobuf::Message {
 public:
  TextMsgGroup();
  virtual ~TextMsgGroup();

  TextMsgGroup(const TextMsgGroup& from);

  inline TextMsgGroup& operator=(const TextMsgGroup& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextMsgGroup& default_instance();

  void Swap(TextMsgGroup* other);

  // implements Message ----------------------------------------------

  TextMsgGroup* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextMsgGroup& from);
  void MergeFrom(const TextMsgGroup& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 src = 1;
  inline bool has_src() const;
  inline void clear_src();
  static const int kSrcFieldNumber = 1;
  inline ::google::protobuf::int32 src() const;
  inline void set_src(::google::protobuf::int32 value);

  // required string data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const char* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:TextMsgGroup)
 private:
  inline void set_has_src();
  inline void clear_has_src();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::int32 src_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static TextMsgGroup* default_instance_;
};
// -------------------------------------------------------------------

class TcpHeartBeatReq : public ::google::protobuf::Message {
 public:
  TcpHeartBeatReq();
  virtual ~TcpHeartBeatReq();

  TcpHeartBeatReq(const TcpHeartBeatReq& from);

  inline TcpHeartBeatReq& operator=(const TcpHeartBeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpHeartBeatReq& default_instance();

  void Swap(TcpHeartBeatReq* other);

  // implements Message ----------------------------------------------

  TcpHeartBeatReq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TcpHeartBeatReq& from);
  void MergeFrom(const TcpHeartBeatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TcpHeartBeatReq)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 data_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static TcpHeartBeatReq* default_instance_;
};
// -------------------------------------------------------------------

class TcpHeartBeatRes : public ::google::protobuf::Message {
 public:
  TcpHeartBeatRes();
  virtual ~TcpHeartBeatRes();

  TcpHeartBeatRes(const TcpHeartBeatRes& from);

  inline TcpHeartBeatRes& operator=(const TcpHeartBeatRes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TcpHeartBeatRes& default_instance();

  void Swap(TcpHeartBeatRes* other);

  // implements Message ----------------------------------------------

  TcpHeartBeatRes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TcpHeartBeatRes& from);
  void MergeFrom(const TcpHeartBeatRes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline ::google::protobuf::int32 data() const;
  inline void set_data(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:TcpHeartBeatRes)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 data_;
  friend void  protobuf_AddDesc_TcpProto_2eproto();
  friend void protobuf_AssignDesc_TcpProto_2eproto();
  friend void protobuf_ShutdownFile_TcpProto_2eproto();

  void InitAsDefaultInstance();
  static TcpHeartBeatRes* default_instance_;
};
// ===================================================================


// ===================================================================

// Person

// required int32 id = 1;
inline bool Person::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Person::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Person::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Person::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Person::id() const {
  // @@protoc_insertion_point(field_get:Person.id)
  return id_;
}
inline void Person::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:Person.id)
}

// required string nickname = 2;
inline bool Person::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Person::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Person::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Person::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& Person::nickname() const {
  // @@protoc_insertion_point(field_get:Person.nickname)
  return *nickname_;
}
inline void Person::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:Person.nickname)
}
inline void Person::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:Person.nickname)
}
inline void Person::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Person.nickname)
}
inline ::std::string* Person::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Person.nickname)
  return nickname_;
}
inline ::std::string* Person::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Person::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Person.nickname)
}

// required string password = 3;
inline bool Person::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Person::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Person::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Person::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& Person::password() const {
  // @@protoc_insertion_point(field_get:Person.password)
  return *password_;
}
inline void Person::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:Person.password)
}
inline void Person::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:Person.password)
}
inline void Person::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Person.password)
}
inline ::std::string* Person::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Person.password)
  return password_;
}
inline ::std::string* Person::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Person::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Person.password)
}

// required string sex = 4;
inline bool Person::has_sex() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Person::set_has_sex() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Person::clear_has_sex() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Person::clear_sex() {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_->clear();
  }
  clear_has_sex();
}
inline const ::std::string& Person::sex() const {
  // @@protoc_insertion_point(field_get:Person.sex)
  return *sex_;
}
inline void Person::set_sex(const ::std::string& value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set:Person.sex)
}
inline void Person::set_sex(const char* value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set_char:Person.sex)
}
inline void Person::set_sex(const char* value, size_t size) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Person.sex)
}
inline ::std::string* Person::mutable_sex() {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:Person.sex)
  return sex_;
}
inline ::std::string* Person::release_sex() {
  clear_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sex_;
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Person::set_allocated_sex(::std::string* sex) {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sex_;
  }
  if (sex) {
    set_has_sex();
    sex_ = sex;
  } else {
    clear_has_sex();
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:Person.sex)
}

// required int32 head = 5;
inline bool Person::has_head() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Person::set_has_head() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Person::clear_has_head() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Person::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 Person::head() const {
  // @@protoc_insertion_point(field_get:Person.head)
  return head_;
}
inline void Person::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
  // @@protoc_insertion_point(field_set:Person.head)
}

// -------------------------------------------------------------------

// RegistReq

// required string nickname = 1;
inline bool RegistReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RegistReq::nickname() const {
  // @@protoc_insertion_point(field_get:RegistReq.nickname)
  return *nickname_;
}
inline void RegistReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set:RegistReq.nickname)
}
inline void RegistReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegistReq.nickname)
}
inline void RegistReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegistReq.nickname)
}
inline ::std::string* RegistReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    nickname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegistReq.nickname)
  return nickname_;
}
inline ::std::string* RegistReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegistReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegistReq.nickname)
}

// required string password = 2;
inline bool RegistReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& RegistReq::password() const {
  // @@protoc_insertion_point(field_get:RegistReq.password)
  return *password_;
}
inline void RegistReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:RegistReq.password)
}
inline void RegistReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegistReq.password)
}
inline void RegistReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegistReq.password)
}
inline ::std::string* RegistReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegistReq.password)
  return password_;
}
inline ::std::string* RegistReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegistReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegistReq.password)
}

// required string sex = 3;
inline bool RegistReq::has_sex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistReq::set_has_sex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistReq::clear_has_sex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistReq::clear_sex() {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_->clear();
  }
  clear_has_sex();
}
inline const ::std::string& RegistReq::sex() const {
  // @@protoc_insertion_point(field_get:RegistReq.sex)
  return *sex_;
}
inline void RegistReq::set_sex(const ::std::string& value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set:RegistReq.sex)
}
inline void RegistReq::set_sex(const char* value) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(value);
  // @@protoc_insertion_point(field_set_char:RegistReq.sex)
}
inline void RegistReq::set_sex(const char* value, size_t size) {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  sex_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RegistReq.sex)
}
inline ::std::string* RegistReq::mutable_sex() {
  set_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sex_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RegistReq.sex)
  return sex_;
}
inline ::std::string* RegistReq::release_sex() {
  clear_has_sex();
  if (sex_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sex_;
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void RegistReq::set_allocated_sex(::std::string* sex) {
  if (sex_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sex_;
  }
  if (sex) {
    set_has_sex();
    sex_ = sex;
  } else {
    clear_has_sex();
    sex_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RegistReq.sex)
}

// required int32 head = 4;
inline bool RegistReq::has_head() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegistReq::set_has_head() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegistReq::clear_has_head() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegistReq::clear_head() {
  head_ = 0;
  clear_has_head();
}
inline ::google::protobuf::int32 RegistReq::head() const {
  // @@protoc_insertion_point(field_get:RegistReq.head)
  return head_;
}
inline void RegistReq::set_head(::google::protobuf::int32 value) {
  set_has_head();
  head_ = value;
  // @@protoc_insertion_point(field_set:RegistReq.head)
}

// -------------------------------------------------------------------

// RegistRes

// required int32 code = 1;
inline bool RegistRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistRes::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 RegistRes::code() const {
  // @@protoc_insertion_point(field_get:RegistRes.code)
  return code_;
}
inline void RegistRes::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:RegistRes.code)
}

// required int32 id = 2;
inline bool RegistRes::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistRes::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistRes::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistRes::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RegistRes::id() const {
  // @@protoc_insertion_point(field_get:RegistRes.id)
  return id_;
}
inline void RegistRes::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:RegistRes.id)
}

// -------------------------------------------------------------------

// LoginReq

// required int32 id = 1;
inline bool LoginReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LoginReq::id() const {
  // @@protoc_insertion_point(field_get:LoginReq.id)
  return id_;
}
inline void LoginReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:LoginReq.id)
}

// required string password = 2;
inline bool LoginReq::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginReq::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginReq::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginReq::clear_password() {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& LoginReq::password() const {
  // @@protoc_insertion_point(field_get:LoginReq.password)
  return *password_;
}
inline void LoginReq::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set:LoginReq.password)
}
inline void LoginReq::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(value);
  // @@protoc_insertion_point(field_set_char:LoginReq.password)
}
inline void LoginReq::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:LoginReq.password)
}
inline ::std::string* LoginReq::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    password_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:LoginReq.password)
  return password_;
}
inline ::std::string* LoginReq::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LoginReq::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:LoginReq.password)
}

// -------------------------------------------------------------------

// LoginRes

// required int32 code = 1;
inline bool LoginRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRes::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LoginRes::code() const {
  // @@protoc_insertion_point(field_get:LoginRes.code)
  return code_;
}
inline void LoginRes::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:LoginRes.code)
}

// repeated .Person person = 2;
inline int LoginRes::person_size() const {
  return person_.size();
}
inline void LoginRes::clear_person() {
  person_.Clear();
}
inline const ::Person& LoginRes::person(int index) const {
  // @@protoc_insertion_point(field_get:LoginRes.person)
  return person_.Get(index);
}
inline ::Person* LoginRes::mutable_person(int index) {
  // @@protoc_insertion_point(field_mutable:LoginRes.person)
  return person_.Mutable(index);
}
inline ::Person* LoginRes::add_person() {
  // @@protoc_insertion_point(field_add:LoginRes.person)
  return person_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Person >&
LoginRes::person() const {
  // @@protoc_insertion_point(field_list:LoginRes.person)
  return person_;
}
inline ::google::protobuf::RepeatedPtrField< ::Person >*
LoginRes::mutable_person() {
  // @@protoc_insertion_point(field_mutable_list:LoginRes.person)
  return &person_;
}

// -------------------------------------------------------------------

// LogoutReq

// required int32 id = 1;
inline bool LogoutReq::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutReq::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 LogoutReq::id() const {
  // @@protoc_insertion_point(field_get:LogoutReq.id)
  return id_;
}
inline void LogoutReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:LogoutReq.id)
}

// -------------------------------------------------------------------

// LogoutRes

// required int32 code = 1;
inline bool LogoutRes::has_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LogoutRes::set_has_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LogoutRes::clear_has_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LogoutRes::clear_code() {
  code_ = 0;
  clear_has_code();
}
inline ::google::protobuf::int32 LogoutRes::code() const {
  // @@protoc_insertion_point(field_get:LogoutRes.code)
  return code_;
}
inline void LogoutRes::set_code(::google::protobuf::int32 value) {
  set_has_code();
  code_ = value;
  // @@protoc_insertion_point(field_set:LogoutRes.code)
}

// required .Person person = 2;
inline bool LogoutRes::has_person() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LogoutRes::set_has_person() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LogoutRes::clear_has_person() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LogoutRes::clear_person() {
  if (person_ != NULL) person_->::Person::Clear();
  clear_has_person();
}
inline const ::Person& LogoutRes::person() const {
  // @@protoc_insertion_point(field_get:LogoutRes.person)
  return person_ != NULL ? *person_ : *default_instance_->person_;
}
inline ::Person* LogoutRes::mutable_person() {
  set_has_person();
  if (person_ == NULL) person_ = new ::Person;
  // @@protoc_insertion_point(field_mutable:LogoutRes.person)
  return person_;
}
inline ::Person* LogoutRes::release_person() {
  clear_has_person();
  ::Person* temp = person_;
  person_ = NULL;
  return temp;
}
inline void LogoutRes::set_allocated_person(::Person* person) {
  delete person_;
  person_ = person;
  if (person) {
    set_has_person();
  } else {
    clear_has_person();
  }
  // @@protoc_insertion_point(field_set_allocated:LogoutRes.person)
}

// -------------------------------------------------------------------

// ShakeMsg

// required int32 src = 1;
inline bool ShakeMsg::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ShakeMsg::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ShakeMsg::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ShakeMsg::clear_src() {
  src_ = 0;
  clear_has_src();
}
inline ::google::protobuf::int32 ShakeMsg::src() const {
  // @@protoc_insertion_point(field_get:ShakeMsg.src)
  return src_;
}
inline void ShakeMsg::set_src(::google::protobuf::int32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:ShakeMsg.src)
}

// required int32 dst = 2;
inline bool ShakeMsg::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ShakeMsg::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ShakeMsg::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ShakeMsg::clear_dst() {
  dst_ = 0;
  clear_has_dst();
}
inline ::google::protobuf::int32 ShakeMsg::dst() const {
  // @@protoc_insertion_point(field_get:ShakeMsg.dst)
  return dst_;
}
inline void ShakeMsg::set_dst(::google::protobuf::int32 value) {
  set_has_dst();
  dst_ = value;
  // @@protoc_insertion_point(field_set:ShakeMsg.dst)
}

// required string data = 3;
inline bool ShakeMsg::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ShakeMsg::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ShakeMsg::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ShakeMsg::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& ShakeMsg::data() const {
  // @@protoc_insertion_point(field_get:ShakeMsg.data)
  return *data_;
}
inline void ShakeMsg::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:ShakeMsg.data)
}
inline void ShakeMsg::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:ShakeMsg.data)
}
inline void ShakeMsg::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:ShakeMsg.data)
}
inline ::std::string* ShakeMsg::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:ShakeMsg.data)
  return data_;
}
inline ::std::string* ShakeMsg::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ShakeMsg::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:ShakeMsg.data)
}

// -------------------------------------------------------------------

// TextMsgPrivate

// required int32 src = 1;
inline bool TextMsgPrivate::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMsgPrivate::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextMsgPrivate::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextMsgPrivate::clear_src() {
  src_ = 0;
  clear_has_src();
}
inline ::google::protobuf::int32 TextMsgPrivate::src() const {
  // @@protoc_insertion_point(field_get:TextMsgPrivate.src)
  return src_;
}
inline void TextMsgPrivate::set_src(::google::protobuf::int32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:TextMsgPrivate.src)
}

// required int32 dst = 2;
inline bool TextMsgPrivate::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMsgPrivate::set_has_dst() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextMsgPrivate::clear_has_dst() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextMsgPrivate::clear_dst() {
  dst_ = 0;
  clear_has_dst();
}
inline ::google::protobuf::int32 TextMsgPrivate::dst() const {
  // @@protoc_insertion_point(field_get:TextMsgPrivate.dst)
  return dst_;
}
inline void TextMsgPrivate::set_dst(::google::protobuf::int32 value) {
  set_has_dst();
  dst_ = value;
  // @@protoc_insertion_point(field_set:TextMsgPrivate.dst)
}

// required string data = 3;
inline bool TextMsgPrivate::has_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextMsgPrivate::set_has_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextMsgPrivate::clear_has_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextMsgPrivate::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TextMsgPrivate::data() const {
  // @@protoc_insertion_point(field_get:TextMsgPrivate.data)
  return *data_;
}
inline void TextMsgPrivate::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:TextMsgPrivate.data)
}
inline void TextMsgPrivate::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TextMsgPrivate.data)
}
inline void TextMsgPrivate::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TextMsgPrivate.data)
}
inline ::std::string* TextMsgPrivate::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TextMsgPrivate.data)
  return data_;
}
inline ::std::string* TextMsgPrivate::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TextMsgPrivate::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TextMsgPrivate.data)
}

// -------------------------------------------------------------------

// TextMsgGroup

// required int32 src = 1;
inline bool TextMsgGroup::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextMsgGroup::set_has_src() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextMsgGroup::clear_has_src() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextMsgGroup::clear_src() {
  src_ = 0;
  clear_has_src();
}
inline ::google::protobuf::int32 TextMsgGroup::src() const {
  // @@protoc_insertion_point(field_get:TextMsgGroup.src)
  return src_;
}
inline void TextMsgGroup::set_src(::google::protobuf::int32 value) {
  set_has_src();
  src_ = value;
  // @@protoc_insertion_point(field_set:TextMsgGroup.src)
}

// required string data = 2;
inline bool TextMsgGroup::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextMsgGroup::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextMsgGroup::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextMsgGroup::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TextMsgGroup::data() const {
  // @@protoc_insertion_point(field_get:TextMsgGroup.data)
  return *data_;
}
inline void TextMsgGroup::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:TextMsgGroup.data)
}
inline void TextMsgGroup::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:TextMsgGroup.data)
}
inline void TextMsgGroup::set_data(const char* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TextMsgGroup.data)
}
inline ::std::string* TextMsgGroup::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:TextMsgGroup.data)
  return data_;
}
inline ::std::string* TextMsgGroup::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TextMsgGroup::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:TextMsgGroup.data)
}

// -------------------------------------------------------------------

// TcpHeartBeatReq

// required int32 data = 1;
inline bool TcpHeartBeatReq::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpHeartBeatReq::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpHeartBeatReq::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpHeartBeatReq::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 TcpHeartBeatReq::data() const {
  // @@protoc_insertion_point(field_get:TcpHeartBeatReq.data)
  return data_;
}
inline void TcpHeartBeatReq::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:TcpHeartBeatReq.data)
}

// -------------------------------------------------------------------

// TcpHeartBeatRes

// required int32 data = 1;
inline bool TcpHeartBeatRes::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TcpHeartBeatRes::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TcpHeartBeatRes::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TcpHeartBeatRes::clear_data() {
  data_ = 0;
  clear_has_data();
}
inline ::google::protobuf::int32 TcpHeartBeatRes::data() const {
  // @@protoc_insertion_point(field_get:TcpHeartBeatRes.data)
  return data_;
}
inline void TcpHeartBeatRes::set_data(::google::protobuf::int32 value) {
  set_has_data();
  data_ = value;
  // @@protoc_insertion_point(field_set:TcpHeartBeatRes.data)
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_TcpProto_2eproto__INCLUDED
